import org.openhab.core.library.types.DateTimeType
import org.joda.time.DateTime

var Number alarmNotBeforeHour = 16
var Number alarmNotAfterHour = 23

var Number minimumIntervalDays = 8
var Number maximumIntervalDays = 14
var Number minimumMembersPresent = 4

rule "Enable Cleanup Alarm on system start"
    System started
then
    sendCommand(cleanupAlarmEnable, ON)

    if(cleanupAlarm.state == Uninitialized) {
	sendCommand(cleanupAlarm, OFF)
    }

    if(fs_beamer.state == Uninitialized) {
	sendCommand(fs_beamer, OFF)
    }
	 
    if(lastCleanupAlarm.state == Uninitialized) {
        postUpdate(lastCleanupAlarm, new DateTimeType())
    }
end

rule "Cleanup Alarm begins"
when
    Item cleanupAlarm changed to ON
then

    postUpdate(lastCleanupAlarm, new DateTimeType())

    // Switch stuff on
    sendMail("security@hackerspace-bamberg.de", "Debug: Cleanup Alarm begin", "Cleanup alarm was triggered")

    /*
    * TODO:
    * - Alarm light on
    * - Send message to ledboard
    * - Play other music on MPD
    * - Trigger panic alarm in lounge if ledbars are on
    */

    // Switch off after a certain time
    createTimer(now.plusMinutes(10)) [|
        sendCommand(cleanupAlarm, OFF)
    ]
end

rule "Cleanup Alarm ends"
when
    Item cleanupAlarm changed to OFF
then
    // Switch stuff off
    sendMail("security@hackerspace-bamberg.de", "Debug: Cleanup Alarm end", "Cleanup alarm ended")

    // Everything off again ;) 
end

rule "Cleanup Alarm manual override"
when
    Item cleanupAlarmEnable changed to OFF
then
    // If the alarm is already ON, and one wants to disable it
    if(cleanupAlarm.state == ON) {
        sendCommand(cleanupAlarm, OFF)
    }
end

rule "Check for cleanup alarm"
when
    Time cron "0 0/23 * * * ?"
then
    /*
    * Check every 23 minutes, only if cleanupAlarm is enabled
    *
    * Only if the door is not locked (which may indicate sleeping members) and
    * no one is watching a movie (don't want to interrupt people)
    *
    * The memberCount should be above a sane value, because no one want's to clean
    * up alone. Also check if the members are at least an hour here, so one can
    * just sit and relax for a while.
    *
    * Also check if there are different members than the last time
    *
    * Also check if the date range is in a good range, no cleanup alarm in the midnight 
    * is triggered.
    *
    * Plus: Add a little bit of random
    */

    // We need to convert it to yodatime before using it with historicState or changedSince
    val lastCleanupJodaTime = new DateTime((lastCleanupAlarm.state as DateTimeType).calendar.timeInMillis)
    val randomValue = Math::random

    logInfo("cleanupAlarm", "Checking for conditions for cleanup")

    if(cleanupAlarmEnable.state == ON &&
        doorLock.state == OPEN && fs_beamer.state == OFF &&
        memberCount.state >= minimumMembersPresent && memberCount.historicState(now.minusHours(1)).state >= minimumMembersPresent && 
        now.getHourOfDay() >= alarmNotBeforeHour && now.getHourOfDay() <= alarmNotAfterHour) {

    	logInfo("cleanupAlarm", "Criterias met, checking for last alarm + random")

        if(!cleanupAlarm.changedSince(now.minusDays(minimumIntervalDays)) &&
            memberNames.state != memberNames.historicState(lastCleanupJodaTime).state && 
            randomValue > 0.9) {

            sendCommand(cleanupAlarm, ON);
        } else if(!cleanupAlarm.changedSince(now.minusDays(maximumIntervalDays))) {

            // No matter what, maximumIntervalDays is enough. We have to clean up. Seriously
            sendCommand(cleanupAlarm, ON);
        }

    }
end
 
